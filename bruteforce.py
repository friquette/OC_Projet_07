import itertools
from time import time
from datetime import timedelta
import csv


def timer(function):
    """
    Function to calculate the execution time of a function. Can simply be used as a decorator.

    :param function: the function which we want the execution time.
    :return returns the result of the new function.
    """
    def new_function(*args, **kwargs):
        start_time = int(round(time() * 1000))
        try:
            return function(*args, **kwargs)
        finally:
            elapsed_time = int(round(time() * 1000)) - start_time
            convert_milliseconds = timedelta(milliseconds=elapsed_time)
            print(f"Temps d'exécution: {convert_milliseconds}")
    return new_function


def create_shares_from_file(read_file: str) -> list:
    """
    Read a .csv file as a dictionary and for each row, create a new dictionary with the 'name'
    column as key, and a second dictionary as value. The second dictionary has two keys: 'price'
    and 'profit'. Last append the dictionary to a shares list.

    :param read_file: the .csv file to read.
    :return: the list of shares created from the read_file.
    """
    shares = []

    with open(read_file, mode='r') as file:
        csv_reader = csv.DictReader(file)
        line_count = 0

        for row in csv_reader:
            shares_dict = {}
            if line_count == 0:
                line_count += 1

            if float(row['price']) > 0:
                shares_dict[row['name']] = {float(row['price']): float(row['profit'])}
                shares.append(shares_dict)

    return shares


def accept_combination(combination: tuple) -> bool:
    """
    Verifies if the total price of the combination is inferior to 500.

    :param combination: tuple of the prices of the current combination.
    :return: True if the total is inferior to 500, False if not.
    """
    total = round(sum(combination), 2)
    if total <= 500:
        return True
    else:
        return False


def compare_combinations(first_cmb: float, second_cmb: float) -> float:
    """
    Compare the current combination profit to the best one.

    :param first_cmb: the profit of the best combination so far.
    :param second_cmb: the profit of the current combination.
    :return: the current combination if it's superior to the best combination.
    """
    return second_cmb if second_cmb > first_cmb else first_cmb


@timer
def main(force: int, read_file: str):
    """
    For each combination possible, verifies if the combination is accepted and then compare it to
    the current best combination. Replace the previous best combination if superior to it.

    :param force: the number of shares we want to combine.
    :param read_file: the datasets file in .csv format.
    :return: the final best combination and the profit generated by this best combination.
    """
    best_benefit = 0
    best_combination = None

    shares = create_shares_from_file(read_file)

    for cmb in itertools.combinations_with_replacement(shares, force):
        combinations = []
        total_benefit = []

        for share_dict in cmb:
            for value in share_dict.values():
                for price in value.keys():
                    combinations.append(price)

        is_accepted = accept_combination(tuple(combinations))
        if is_accepted:
            for item in cmb:
                for v in item.values():
                    for price, benefit in v.items():
                        absolute_benefit = round((price * benefit)/100, 2)
                        total_benefit.append(absolute_benefit)
            comparison = compare_combinations(best_benefit, sum(total_benefit))
            if best_benefit < comparison:
                best_benefit = comparison
                best_combination = cmb

    return best_combination, f"{round(best_benefit, 2)}€"


if __name__ == "__main__":
    for i in range(1, 17):
        with open("reports/bruteforce_with_replacement_report.txt", mode='r+') as writing_file:
            if f"Force {i}" not in str(writing_file.read()):
                print(f"Force {i} calculating...")
                final_result = main(i, 'csv/bruteforce.csv')
                writing_file.write(f"Force {i}: meilleur combinaison = {final_result} \n")
